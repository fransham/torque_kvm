#!/usr/bin/env python
################################################################
#
#  submit filter.  This script takes the user's submit file, and
#  customizes it to pipe it via ssh into the vm.
#  The script reads the user's job file from STDIN, and sends
#  the customzed file to STDOUT.  The output file, when executed
#  as a job, will write the original job to a file, copy that job
#  to the vm, and execute it via ssh
#
#################################################################

import re
import sys

#customize any system defaults you want in here.
#memory should be small, since all it's doing is running ssh
system_defaults='''
#PBS -l mem=16MB
#PBS -l walltime=48:00:00 
#PBS -l nodes=1 
#PBS -l ncpus=1
#PBS -S /bin/bash
'''

#global variables
torque_home="/var/spool/torque"
target_host=torque_home+'/virt/${PBS_JOBID}'
target_script=target_host+'.job'
bash_envs=target_host+'.bash_envs'
tcsh_envs=target_host+'.tcsh_envs'
userenvs=[]
pbs_directives=[]

#torque environment variables to send to the job
envvars_to_job=("PBS_O_HOST","PBS_O_LOGNAME",
    "PBS_O_HOME","PBS_O_WORKDIR","PBS_ENVIRONMENT",
    "PBS_O_QUEUE","PBS_JOBID", "PBS_JOBNAME",
    "PBS_NODEFILE")
    
# put your filters into this array to have them applied to the data
# write any new filters you want and add them to this list.
filters=[
		 lambda x: csh_shell_filter(x),
         lambda x: environment_filter(x),  
         lambda x: pbs_directive_filter(x)
         ]

# The main function.  It all starts here!
def main():
    # filter the command line arguments first:
    cmd_line_arg_filter()
    
    #get the user's job script from STDIN
    data = sys.stdin.readlines()

    #check if we want a baremetal session.  
    check_baremetal(data)
    
    #apply the filters to the #PBS directives
    userjob = apply_filters(data)
    
    #write the directives to the job file
    write_pbs_directives()
    
    #set the job targets
    write_targets()
    
    #setup the job for the proper shell
    setup_job()
    
    #write the user's job to a file:
    write_job(userjob)

    
#apply the filters.
def apply_filters(data):
    filtered_data=[]
    for line in data:
        output = line.rstrip()
        for filter in filters:
            output = filter(output)
        filtered_data.append(output)
    return filtered_data


# check if the user requested a baremetal session.  This means that we don't filter the job at all.
def check_baremetal(userjob):
    for line in userjob:
		if re.match('\#PBS\s+\-l.*other=baremetal',line):
			print userjob
			sys.exit(0)

#filter the command line arguments first.  Check for
#environment variables to pass to the job and memory request.   
#Memory requests from 
#the command line cannot be overwritten, so the job is
#rejected.  Memory specifications in the submit script is fine.
#Reject -S flag.
#if we want a baremetal session, just quit without doing anything.
def cmd_line_arg_filter():
	i = iter(sys.argv)
	try:
		while(True):
			arg = i.next()
			if arg == '-v':
				global userenvs
				userenvs.extend(re.split(',',i.next()))
			elif arg == '-l':
				opt=i.next()
				if re.match('.*mem\=.*', opt):
					print "Sorry, memory cannot be specified on the command line."
					print "Please add it to your submit script."
					sys.exit(-1)
				if re.match('.*other\=baremetal.*', opt):
					sys.exit(0)
			elif arg == '-S':
				print "Cannot specify a shell."
				print "Your job will execute in your default shell.  Add a #!/bin/SHELL to your"
				print "submit script to execute in a different environment."
				sys.exit(-1)
				if re.match('.*other\=baremetal.*', i.next()):
					sys.exit(-1)
	except StopIteration:
		pass


# we don't want to run with large amounts of memory, since our job just runs ssh.
# replace a memory request with one that's 100 times smaller.
def memory_filter(tocheck):
    newrequest = tocheck
    if re.match('\#PBS\s+\-l.*mem=',tocheck):
        resource = (re.split('\s+|,',tocheck.rstrip())[2:])
        for request in resource:
            if re.match('mem=',request):
                old=request[4:]
                suffix=old[-2:]
                if re.match('^[g|G]',suffix):
                        suffix="MB"
                elif re.match('^[m|M]', suffix):
                        suffix="KB"
                else:
                        "please specify a memory in MB or GB.  Your job will need at least 512MB to run properly"
                        sys.exit(-1)
                new=old[:-2]+"0"+suffix            
        newrequest =  tocheck.replace(old, new)
    return newrequest
    
# find environment variables in job script:
def environment_filter(tocheck):  
    if re.match('\#PBS\s+\-v',tocheck):
        global userenvs
        userenvs.extend(re.split('\s+|,',tocheck.rstrip())[2:])     
    return tocheck

#strip out all #PBS directives:
def pbs_directive_filter(tocheck):
    if re.match('\#PBS',tocheck):
        global pbs_directives
        pbs_directives.extend([tocheck.rstrip()])
    return tocheck
    
#check if the user wants a csh or tcsh
def csh_shell_filter(tocheck):
	if re.match('\#PBS\s+\-S.*csh',tocheck):
		return '#PBS -S /bin/bash'
	return tocheck
        
def write_pbs_directives():
    print system_defaults
    for directive in pbs_directives:
        print directive

def write_targets():
    print 'export TARGET_HOST=`cat '+target_host+'`'
    print 'export TARGET_SCRIPT='+target_script	
    print 'export BASH_ENVS='+bash_envs
    print 'export TCSH_ENVS='+tcsh_envs


#setup the job for the right environment
def setup_job():
	setup_job_csh()
	setup_job_bash()
      
# write  job for bash shells:
def setup_job_bash():
    for var in envvars_to_job:
        print 'echo export '+var+'=$'+var+' >> $BASH_ENVS'
    for var in userenvs:
        print 'echo export '+var+' >> $BASH_ENVS'


#setup job for cshells 
def setup_job_csh():
    for var in envvars_to_job:
        print 'echo setenv '+var+' $'+var+' >> $TCSH_ENVS'
    for var in userenvs:
        print 'echo setenv '+var.replace('=',' ')+' >> $TCSH_ENVS'

#write the actual user's job 
def write_job(userjob):
    #switch to the correct initial directory
    print 'echo cd $PBS_O_WORKDIR >> $TARGET_SCRIPT'
    
    #write the user's script to the job file
    for line in userjob:
        print 'echo \''+line.replace('\'','\'\\\'\'').rstrip()+'\' >> $TARGET_SCRIPT'

    #stall to make sure the VM has come online.  If it's not online after
    #5 mins, it's probably not coming up, and the other commands will fail too.
    #The user will see connection timed out in the job log
    print 'ssh -o ConnectionAttempts=300 ${TARGET_HOST} "/bin/true"'

    #the vm is online now.  Copy the env and job files.
    print 'scp ${BASH_ENVS} ${TARGET_HOST}:/tmp/bash_environment'
    print 'scp ${TCSH_ENVS} ${TARGET_HOST}:/tmp/tcsh_environment'
    print 'scp ${TARGET_SCRIPT} ${TARGET_HOST}:/tmp/${PBS_JOBID}'

    #make the job file execuable
    print 'ssh ${TARGET_HOST} "chmod 755 /tmp/${PBS_JOBID}"'

    #run the job.  
    print 'ssh ${TARGET_HOST} "/tmp/${PBS_JOBID}"'

    #cleanup the job script
    print 'rm $TARGET_SCRIPT'
    
if __name__ == "__main__":
    main()
