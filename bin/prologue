#!/usr/bin/env python

##############################################
# 
# This is a prologue script for torque.  It 
# will boot a virtual machine for a job.
#
##############################################
import sys
import commands
import os
import time
import libvirt
import re
import ConfigParser
import shutil

try:
    import sqlite3
except:
    from pysqlite2 import dbapi2 as sqlite3


# prologue gets 7 arguments:
# 1 -- jobid
# 2 -- userid
# 3 -- grpid
# 4 -- job name
# 5 -- list of requested resources
# 6 -- queue
# 7 -- job account
jobid=sys.argv[1]
userid=sys.argv[2]
groupid=sys.argv[3]
requested_resources=sys.argv[5]
queue=sys.argv[6]
bits=jobid.split('.')
uuid='vm-'+bits[0]

#parameters and global variables
config = ConfigParser.ConfigParser()
config.read('/etc/torque-kvm.conf')
torque_home=config.get("torque","torque_home")
vmrundir = config.get("virt", "vmrundir")
dbfile=torque_home + "/net/network.db"
conn=sqlite3.connect(dbfile)
lockfile=torque_home + "/net/db.lock"
target_hostfile=torque_home+"/virt/"+jobid
shared_hostfile = config.get('virt','shared_hostfile_dir')+'/'+jobid
hostname = None
output_message= '''
------------------------------------------------------------------
TORQUE PROLOGUE:
  jobid:               '''+jobid+'''
  userid:              '''+userid+'''
  requested resources: '''+requested_resources+'''
  queue:               '''+queue+'''
'''



def main():

	#check if this is a parallel job, and return the number
	#of cores the VM should have:
	ncpus = check_parallel()

	#get imagepath from keyword and resource info:
	imagepath = get_image_path(get_keyword())

	#check if the imagepath is for a baremetal session:
	check_image(imagepath)

	#clone the backing image:
	target = clone_image(imagepath)

	#get free hostname/mac:
	(host,mac) = get_host_mac()

	#create the xml and boot the vm:
	boot_vm(create_xml(target,mac,ncpus,get_memory(int(ncpus))))

	# write the job file:
	write_jobfiles(hostname,ncpus)

	#cleanup and exit:
	finalize()
	

# get keyword:
def get_keyword():
	return parse_resources('other')

# check if this is a parallel job, and return the appropriate # of cpus
def check_parallel():
	if os.path.basename(__file__) == 'prologue.parallel':
		while not os.path.exists(shared_hostfile):
			time.sleep(1)
	else:
		shutil.copy(torque_home+'/aux/'+jobid,shared_hostfile)
	
	hostfile = open(shared_hostfile,'r')
	target_nodes = hostfile.readlines()

	if len(target_nodes) == 1:
		ncpus = parse_resources('ncpus')
		if ncpus:
			return ncpus
		return '1'

	ncpus = 0; 
	current_hostname = os.uname()[1].strip()
	for host in target_nodes:
		print host+"  "+current_hostname
		if host.strip() == current_hostname:
			ncpus += 1
	if ncpus < 1:
		do_exit_error("Error parsing hosts_file")
	return ncpus

def get_memory(num_cpus):
	mempercore = config.getint("virt","mempercore")
	return str( num_cpus * mempercore * 1048)	

def parse_resources(tofind):
	if re.match('.*'+tofind+'=.*', requested_resources):
		request = re.split(',',requested_resources.rstrip())
		for resource in request:
			if resource.startswith(tofind+'='):
				match = re.split('=',resource)[1]
				return match
	return ""

# get image path:
def get_image_path(keyword):
	request = config.get('resources','map')
	rules = request.split(';')
	for rule in rules:
		sections = rule.strip().split(' ')
		if ( ( sections[0] == queue or sections[0] == '%' ) and
			 ( sections [1] == keyword or sections[1] == '%') and
			 ( sections [2] == userid or sections[2] == '%') and
			 ( sections [3] == groupid or sections[3] == '%') ):
			return sections[4].strip()
			

#check the image path.  Exit if it's for a baremetal session:
def check_image(imagefile):
	global output_message
	if imagefile == None or imagefile == "None":
		output_message += '''  session type:        baremetal
------------------------------------------------------------------'''	
		open(target_hostfile, 'w').close() 
		os.chmod(target_hostfile, 644)
		do_exit()

	if not os.path.exists(imagefile):
		do_exit_error( ' Cannot file image file: '+imagefile )

	output_message += '  imagefile:           '+imagefile+"\n"

#clone the image:
def clone_image(imagefile):
	target=vmrundir+'/'+uuid
	(ret, out) = commands.getstatusoutput('qemu-img create -b '+imagefile+' -f qcow2 '+target)
	if (ret != 0):
		 do_exit_error("Error creating image.  Error message follows: \n" + out) 
	return target

#get a lock on the database
def lock_db():
	count=0
	while(count < 60):
		try:
			os.mkdir(lockfile)
			break
		except OSError:
			time.sleep(1)
			count+=1

	if (count >= 60):
		do_exit_error( "could not acquire lock on db... exiting." )

#get a hostname and mac from the database
def get_host_mac():
	lock_db()
	global conn
	c=conn.cursor()
	c.execute('select * from reservations where inuse = 0')

	try:
		(host,ip,mac,inuse) = c.next()
	except StopIteration:
		do_exit_error( "no free network slots!" )

	# update the db
	c.execute("update reservations set inuse = 1 where hostname=?",[host])
	conn.commit()
	c.close()

	#release the lock
	release_db_lock()

	#set the global var
	global hostname
	hostname = host

	return (host,mac)

# create the libvirt xml for our domain
def create_xml(target,mac,ncpus,mem):
	xmldesc="""<domain type='kvm'>
  <name>"""+uuid+"""</name>
  <memory>"""+mem+"""</memory>
  <vcpu>"""+ncpus+"""</vcpu>
  <os>
    <type>hvm</type>
    <boot dev='hd'/>
  </os>
  <devices>
    <emulator>/usr/libexec/qemu-kvm</emulator>
    <disk type='file' device='disk'>
      <driver name='qemu' type='qcow2'/>
      <source file='"""+target+"""'/>
      <target dev='hda'/>
    </disk>
    <interface type='bridge'>
      <mac address='"""+mac+"""'/>
      <source bridge='br0'/>
      <target dev='"""+uuid+"""-0'/>
      <model type='virtio'/>
    </interface>
  </devices>
</domain>

"""
	return xmldesc

# Boot the vm
def boot_vm(xmldesc):
	try:
		lconn = libvirt.open(None)
		dom = lconn.createLinux(xmldesc, 0)
		if dom == None:
			do_exit_error("Failed to boot VM")
	except:
		do_exit_error("Failed to boot VM")	
    

# write the hostname of the booted vm to a file so that the
# user's job can read it.  Create a second mpi-style hostfile
# for mpi jobs
def write_jobfiles(host,ncpus):
	jobfile = open(target_hostfile,'w')
	jobfile.write(host)
	jobfile.close()
	os.chmod(target_hostfile,644)
	jobfile2 = open(shared_hostfile+'.vm', 'a');
	jobfile2.write(host+' slots='+ncpus+'\n')
	jobfile2.close
	os.chmod(shared_hostfile+'.vm', 644)

def finalize():
	global output_message
	output_message+= "  host:                " + hostname + '''
------------------------------------------------------------------

'''
	do_exit()

def release_db_lock():
	try:		
		os.rmdir(lockfile)	
	except:
		pass

def do_exit():
	print output_message
	sys.exit(0)

def do_exit_error( message ):
	try:
		lconn = libvirt.open(None)
		dom = lconn.lookupByName(uuid)
		dom.destroy()
	except:
		pass
	if hostname:
		global conn
		c=conn.cursor()
		c.execute("update reservations set inuse = 0 where hostname=?",[hostname])
		conn.commit()
		c.close()
	release_db_lock()	
	sys.stderr.write(message)
	sys.exit(1)

if __name__ == "__main__":
	try:
		main()
	except  KeyboardInterrupt:
		do_exit_error("Prologue interrupted")
