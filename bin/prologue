#!/usr/local/bin/python2.7

##############################################
# 
# This is a prologue script for torque.  It 
# will boot a virtual machine for a job.
#
##############################################
import sys
import commands
import os
import time
import libvirt
import re
import ConfigParser
import shutil
import socket
import pprint

try:
    import sqlite3
except:
    from pysqlite2 import dbapi2 as sqlite3

import subprocess
from threading import Thread

# This class is used to wait for a host to become online.
# It will simply attempt to ping it every 1s, until ping
# returns successfully (exit code 0).
class PingWaiter(Thread):
    def __init__(self, host):
        Thread.__init__(self)
        self.host = host

    def run(self):
        # First let's wait for ping to be successfull
        while True:
            retcode = subprocess.call(['ping','-n','-c','1',self.host], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            sys.stdout.write('.')
            sys.stdout.flush()
            if retcode == 0:
		break
            time.sleep(1)

        # Now lets wait for ssh (port 22) to become alive
        while True:
            sys.stdout.write('+')
            sys.stdout.flush()
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect((self.host, 22))
                s.close()
                break
            except Exception, e:
                time.sleep(1)



# prologue gets 7 arguments:
# 1 -- jobid
# 2 -- userid
# 3 -- grpid
# 4 -- job name
# 5 -- list of requested resources
# 6 -- queue
# 7 -- job account
jobid=sys.argv[1]
userid=sys.argv[2]
groupid=sys.argv[3]
requested_resources=sys.argv[5]
queue=sys.argv[6]
bits=jobid.split('.')
vmuuid='vm-'+bits[0]

#parameters and global variables
config = ConfigParser.ConfigParser()
config.read('/etc/torque-kvm.conf')
torque_home=config.get("torque","torque_home")
vmrundir = config.get("virt", "vmrundir")
dbfile=torque_home + "/net/network.db"
conn=sqlite3.connect(dbfile)
lockfile=torque_home + "/net/db.lock"
target_hostfile=torque_home+"/virt/"+jobid
shared_hostfile = config.get('virt','shared_hostfile_dir')+'/'+jobid
hostname = None

# Load amqp libraries if needed and read related settings from
# config file.
enable_monitoring = False
if config.has_option("monitoring", "enable_monitoring"):
    enable_monitoring = config.getboolean("monitoring", "enable_monitoring")
amqp_host = None
amqp_exchange = None
if enable_monitoring:
    try:
        import pika
        import json
        amqp_host = config.get("monitoring", "amqp_host")
        amqp_exchange = config.get("monitoring", "amqp_exchange")
        print 'Configured to report monitoring data to %s:%s' % (amqp_host, amqp_exchange)
    except Exception, e:
        print '%s' % (e)
        print 'libraries required for ampq not found; monitoring/accounting disabled'
        enable_monitoring = False
else:
    print 'monitoring/accounting disabled'
    


output_message= '''
------------------------------------------------------------------
TORQUE PROLOGUE:
  jobid:               '''+jobid+'''
  userid:              '''+userid+'''
  requested resources: '''+requested_resources+'''
  queue:               '''+queue+'''
'''



def main():

	#check if this is a parallel job, and return the number
	#of cores the VM should have:
	ncpus = get_cpus()

	#get imagepath from keyword and resource info:
	imagepath = get_image_path(get_keyword())

	#check if the imagepath is for a baremetal session:
	check_image(imagepath)

	#clone the backing image:
	target = clone_image(imagepath)

	#get free hostname/mac:
	(host,mac) = get_host_mac()

        # get bridge to connect to
        bridge = 'br0' # default to br0
        if config.has_option("virt", "bridge"):
            bridge = config.get("virt", "bridge")
            
	#create the xml and boot the vm:
        report_data('boot_process_start', [target,mac,bridge,ncpus,get_memory(int(ncpus)), host, userid])
	boot_vm(create_xml(target,mac,bridge,ncpus,get_memory(int(ncpus))), host)
        report_data('boot_process_end', None)
        
	# write the job file:
	write_jobfiles(host,ncpus,get_mpi_flavor(get_keyword()))

	#cleanup and exit:
	finalize()
	

# get keyword:
def get_keyword():
	return parse_resources('other')

# check if this is a parallel job, and return the appropriate # of cpus
def get_cpus():

	ncpus = parse_resources('nodes=.*ppn')
	if ncpus:
		return ncpus

	ncpus = parse_resources('ncpus')
	if ncpus:
		return ncpus

	return '1'


def get_memory(num_cpus):
	mempercore = config.getint("virt","mempercore")
	return str( num_cpus * mempercore * 1048)	

def parse_resources(tofind):
	if re.match('.*'+tofind+'=.*', requested_resources):
		request = re.split(',',requested_resources.rstrip())
		for resource in request:
			if re.match(tofind+'=',resource):
				match = re.split('=',resource)[-1]
				return match
	return ""

# get image path:
def get_image_path(keyword):
    return get_session_parameter(keyword, 'img')

def get_mpi_flavor(keyword):
    return get_session_parameter(keyword, 'mpi_flavor')

# returns a key->value dictionary of the session parameters
# for a particular rule
def get_session_parameters(keyword):
    request = config.get('resources','map')
    rules = request.split(';')
    parameters = {}
    for rule in rules:
        sections = rule.strip().split(' ')
        if ( ( sections[0] == queue or sections[0] == '%' ) and
             ( sections[1] == keyword or sections[1] == '%') and
             ( sections[2] == userid or sections[2] == '%') and
             ( sections[3] == groupid or sections[3] == '%') ):
            for keyvaluepair in sections[4:]:
                parameters[keyvaluepair.split('=')[0].strip()] = keyvaluepair.split('=')[1].strip()
            break
    return parameters

def get_session_parameter(keyword, name):
    parameters = get_session_parameters(keyword)
    if name in parameters:
        return parameters[name]
    else:
        return None
    
#check the image path.  Exit if it's for a baremetal session:
def check_image(imagefile):
	global output_message
	if imagefile == None or imagefile == "None":
		output_message += '''  session type:        baremetal
------------------------------------------------------------------'''	
		open(target_hostfile, 'w').close() 
		os.chmod(target_hostfile, 644)
		do_exit()

	if not os.path.exists(imagefile):
		do_exit_error( ' Cannot file image file: '+imagefile )

	output_message += '  imagefile:           '+imagefile+"\n"

#clone the image:
def clone_image(imagefile):
	target=vmrundir+'/'+vmuuid
	(ret, out) = commands.getstatusoutput('qemu-img create -b '+imagefile+' -f qcow2 '+target)
	if (ret != 0):
		 do_exit_error("Error creating image.  Error message follows: \n" + out) 
	return target

#get a lock on the database
def lock_db():
	count=0
	while(count < 60):
		try:
			os.mkdir(lockfile)
			break
		except OSError:
			time.sleep(1)
			count+=1

	if (count >= 60):
		do_exit_error( "could not acquire lock on db... exiting." )

#get a hostname and mac from the database
def get_host_mac():
	lock_db()
	global conn
	c=conn.cursor()
	c.execute('select * from reservations where inuse = 0')

	try:
		(host,ip,mac,inuse) = c.next()
	except StopIteration:
		do_exit_error( "no free network slots!" )

	# update the db
	c.execute("update reservations set inuse = 1 where hostname=?",[host])
	conn.commit()
	c.close()

	#release the lock
	release_db_lock()

	#set the global var
	global hostname
	hostname = host

	return (host,mac)

# create the libvirt xml for our domain
def create_xml(target,mac,bridge,ncpus,mem):
	xmldesc="""<domain type='kvm'>
  <name>"""+vmuuid+"""</name>
  <memory>"""+mem+"""</memory>
  <vcpu>"""+ncpus+"""</vcpu>
  <os>
    <type>hvm</type>
    <boot dev='hd'/>
  </os>
  <devices>
    <emulator>/usr/libexec/qemu-kvm</emulator>
    <disk type='file' device='disk'>
      <driver name='qemu' type='qcow2'/>
      <source file='"""+target+"""'/>
      <target dev='hda'/>
    </disk>
    <interface type='bridge'>
      <mac address='"""+mac+"""'/>
      <source bridge='"""+bridge+"""'/>
      <target dev='"""+vmuuid+"""-0'/>
      <model type='virtio'/>
    </interface>
  </devices>
</domain>

"""
	return xmldesc

# Boot the vm
def boot_vm(xmldesc, hostname):
	try:
		lconn = libvirt.open(None)
		dom = lconn.createLinux(xmldesc, 0)
		if dom == None:
			do_exit_error("Failed to boot VM")

                # Wait for the VM to become online
                print 'Waiting for VM to become online... Please wait.'
                pingWaiter = PingWaiter(hostname)
		pingWaiter.start()
                pingWaiter.join(5.0*60.0) # 5 minute timeout
                if pingWaiter.isAlive():
                    # If we get here, this means that a timeout occurred.
                    do_exit_error("Failed to boot VM; ping timeout")
	except:
		do_exit_error("Failed to boot VM")	
    

# write the hostname of the booted vm to a file so that the
# user's job can read it.  Create a second mpi-style hostfile
# for mpi jobs
def write_jobfiles(host,ncpus,mpi_flavor):
	jobfile = open(target_hostfile,'w')
	jobfile.write(host)
	jobfile.close()
	os.chmod(target_hostfile,644)
	jobfile2 = open(shared_hostfile, 'a');

        if mpi_flavor is None or mpi_flavor == 'openmpi':
            jobfile2.write(host+' slots='+ncpus+'\n')
        elif mpi_flavor == 'mpich':
            jobfile2.write('%s:%s\n' % (host, ncpus))
        else:
            print 'Error: Unrecognized MPI flavor %s\nUsing openmpi as fallback.' % (mpi_flavor)
            jobfile2.write(host+' slots='+ncpus+'\n')
            
	jobfile2.close
	os.chmod(shared_hostfile, 644)

def finalize():
	global output_message
	output_message+= "  host:                " + hostname + '''
------------------------------------------------------------------

'''
	do_exit()

def release_db_lock():
	try:		
		os.rmdir(lockfile)	
	except:
		pass

def do_exit():
	print output_message
	sys.exit(0)

def do_exit_error( message ):
	try:
		lconn = libvirt.open(None)
		dom = lconn.lookupByName(vmuuid)
		dom.destroy()
	except:
		pass
	if hostname:
		global conn
		c=conn.cursor()
		c.execute("update reservations set inuse = 0 where hostname=?",[hostname])
		conn.commit()
		c.close()
	release_db_lock()	
	sys.stderr.write(message)
	sys.exit(1)


# Report back some data to the central amqp server.
def report_data(key, value):
    global vmuuid
    if not enable_monitoring:
        return
    
    connection = pika.BlockingConnection(pika.ConnectionParameters(host=amqp_host))
    channel = connection.channel()
    channel.exchange_declare(exchange=amqp_exchange, type='fanout')
    data = {}
    data['instance_uuid'] = vmuuid
    data['timestamp'] = time.time()
    data['key'] = key
    data['data'] = value
    channel.basic_publish(exchange=amqp_exchange, routing_key='', body=json.dumps(data))
    connection.close()
    pprint.pprint(data)


if __name__ == "__main__":
	try:
		main()
	except  KeyboardInterrupt:
		do_exit_error("Prologue interrupted")
